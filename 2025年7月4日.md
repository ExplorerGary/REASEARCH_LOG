# 2025年7月4日

## 今天的安排：
1. 修复EG算法重新计算
    老师的指示：

    你针对什么东西算的压缩率？H5? 
    1）我们首先要对实际系统中传输的数据做压缩和计算压缩率 
        -- 是的。我是对tensor本身进行压缩和计算的
                压缩的计算方式如下：
                base = 原tensor长度*2 (因为是fp16)
                compressed = 运行了EG后的bin串长度/8 （一个byte = 8个bit）
                compression_ratio = (base-compresses)/base

    2）存成H5主要是为我们Matlab处理方便，我们不一定需要和H5比较压缩效率，但是最好比它的效率高，否则显得我们很蠢 
        -- 好的，我明白了。
    3）你要确认你的压缩效率是不是算对了，以及EG是不是用了合适的参数。这个你可以向@熊一荣 师姐请教一下
        -- 没问题，我现在跟她联系，等待她的指导。
    4）转小数不就是查表么？
        -- 回复：
        我不是很能明白“转小数不就是查表么”指的是什么？如果方便的话，能否请您具体举个例子，说明在哪个环节查表可以替代当前的处理逻辑？我担心自己可能误解了您的意思。

        目前我这个算法是这样实现的，如果有不对还请您指正：
        
        输入：bucket里的tensor，dtype = fp16
        输出：由他每一位转化出来的字符串的list

        可视化：
        pt_array = [1,2,3,……,n]
        compressed_array = ["010", "011", "00100", ……]

        已知
        1. EG算法原生只支持整数
        2. pt_array里面有负数，数量级最小约为10^ -8

        设计：
        读入pt_array后：
        1. 乘上10^ 8
        2. zigzag编码为非负整数
        3. 运行EG编码
        4. 计算压缩率

        我不是很能明白“转小数不就是查表么”指的是什么？如果方便的话，能否请您具体举个例子，说明在哪个环节查表可以替代当前的处理逻辑？我担心自己可能误解了您的意思。
    
    -- 更新：我找到了一个叫做bitstring的包，我自己的除了放缩以外的算法实现，均已经被废弃。

2. 完成h5转化器
    -- 完成，但是效率有待提升

    -- 考虑学习如何并行写入而且保证顺序不要发生改变
        
    -- 或者维护一个index表格，记录每一个东西的去向

